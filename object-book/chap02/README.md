# chap02 객체지향 프로그래밍

### 진정한 객체지향 패러다임으로의 전환
클래스가 아닌 객체에 초점을 맞춰야 함

1. 어떤 클래스가 필요한지를 고민하기 전에 어떤 객체들이 필요한지 고민하라.
2. 객체를 독립적인 존재가 아니라 기능을 구현하기 위해 협력하는 공동체의 일원으로 봐야 한다.

### 도메인
문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야


### 자율적인 객체
1. 객체는 상태(state)와 행동(behavior)을 함께 가지는 복합적인 존재이다.
* 캡슐화를 통해 데이터와 기능을 객체 내부로 함꼐 묶음

2. 객체는 스스로 판단하고 행동하는 자율적인 존재이다. 
* 접근 제어자를 통해 객체를 자율적인 존재로 만듦
* 객체 지향의 핵심은 스스로 상태를 관리, 판단, 행동하는 자율적인 객체들의 공동체를 구성하는 것
* 외부에서의 개입을 막고, 객체 스스로가 행동하게 함으로서 자율적인 존재로 만듦

`퍼블릭 인터페이스` 외부에서 접근 가능한 부분  
`구현` 외부에서 접근 불가능하고 오직 내부에서만 접근 가능한 부분  
-> **인터페이스와 구현의 분리 원칙**


 ### 협력
* 객체는 다른 객체의 인터페이스에 공개된 행동을 수행하도록 **요청**
* 요청을 받은 객체는 자율적인 방법에 따라 요청을 처리한 후 **응답**  


* 객체가 다른 객체와 상호작용할 수 있는 유일한 방법은 **메시지를 전송**
* 다른 객체에게 요청이 도착할 때 해당 객체가 **메시지를 수신**
* 수신된 메시지를 처리하기 위한 자신만의 방법을 **메서드** 라고 부름  
-> 메시지와 메서드를 구분하는 것은 중요

### 템플릿 패턴
부모 클래스에 기본적인 알고리즘의 흐름을 구현하고 중간에 필요한 처리를 자식 클래스에게 위임하는 디자인 패턴

### 차이에 의한 프로그래밍
부모 클래스와 다른 부분만을 추가해서 새로운 클래스를 쉽고 빠르게 만드는 방법

### 업캐스팅
자식클래스가 부모클래스를 대신하는 것

### 다형성
* 동일한 메시지를 전송하지만 실제로 어떤 메서드가 실행될 것인지는 메시지를 수신하는 객체의 클래스가 무엇이냐에 따라 달라짐  
* 다형성은 객체지향 프로그램의 컴파일 시간 의존성과 실행 시간 의존성이 다를 수 있다는 사실을 기반으로함
* 동일한 메시지를 수산했을 때 객체의 타입에 따라 다르게 응답할 수 있는 능력
* `지연 바인딩` 메시지와 메서드를 실행 시점에 바인딩 하는 것
* `초기 바인딩` 전통적인 함수 호출처럼 컴파일 시점에 실행될 함수나 프로시저를 결정하는 것

### 추상화의 힘
1. 추상화 계층만 따로 떼어 놓고 보면 요구사항의 정책을 높은 수준에서 서술할 수 있음
* 세부 내용을 무시한 채 상위 정책을 쉽고 간단하게 표현할 수 있음
2. 추상화를 이용하면 설계가 더 유연해짐

### 상속의 단점
1. 캡슐화 위반 
* 부모 클래스의 구현이 자식 클래스에게 노출되기 띠문에
* 부모 클래스가 변경될 때 자식 클래스도 변경될 확률이 높음
2. 설계를 유연하지 못하게 만듦 
* 부모 클래스와 자식 클래스 사이의 관계를 컴파일 시점에 결정
* 실행 시점에 객체의 종류를 변경하는것이 불가

### 합성
안터페이스에 정의된 메시지를 통해서만 코드를 재사용하는 방법  
상속이 가지는 두 가지 문제좀을 모두 해결
* 인터페이스에 정의된 메시지를 통해서만 재사용이 가능하기 때문에 구현을 효과적으로 캡슐화
* 의존하는 인터페이스를 교체하는 것이 비교적 쉽기 때문에 설계를 유연하게 만듦


