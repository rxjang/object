# chap03 역할, 책임, 협력

## 객체지향 패러디임의 핵심
1. 역할
2. 책임
3. 협력  

* 클래스, 상속, 지연 바인딩은 구현 측면에 치우쳐 있어 객체지향 패다임의 본질과는 거리가 멀다.
* 객체지향의 본질은 **협력하는 객체들의 공동체를 창조**하는 것.

## 협력
* 객체지향 세계에서 기능을 구현할 수 있는 유일한 방법
* 하나의 객체가 다른 객체에게 도움을 요청할 때 시작
* 메시지 전송은 객체 사이의 협력을 위해 사용할 수 있는 유일한 커뮤니케이션 수단
* 메시지를 수신한 객체는 메서드를 실행해 요청에 응답

### 협력이 설계를 위한 문맥을 결정한다
객체는 협력에 참여하고 있기 때문에 객체의 필요 이유는 단 하나여야 한다.  객체가 협력에 참여할 수 있는 이유는 협력에 필요한 적절한 행동을 보유하고 있기 때문이다. 즉, **객체의 행동을 결정하는 것은 객체가 참여하고 있는 협력이다.**

* 객체의 행동을 결정하는 것 -> 협력
* 객체의 상태를 결정하는 것 -> 행동 (행동을 수행하는데 필요한 정보)  
ㄴ
결과적으로 객체가 참여하는 협력이 객체를 구성하는 행동과 상태를 모두 결정한다. 즉, 협력은 객체를 설계하는데 필요한 일종의 문맥을 제공한다.  

  
## 책임
* 협력에 참여하기 위해 객체가 수행하는 행동
* 객체에 의해 정의되는 응집도 있는 행위의 집합
* 객체가 유지해야하는 정보와 수행할 수 있는 행동에 대해 서술한 문장
* **무엇을 알고 있는가**와 **무엇을 할 수 있는 가**로 구성

`하는 것`
* 객체를 생성하거나 개산을 수행하는 등의 스스로 하는 것
* 다른 객체의 행동을 시작시키는 것
* 다른 객체의 활동을 제어하고 조절하는 것

`아는 것`
* 사적인 정보에 관해 아는 것
* 관련된 객체에 관해 아는 것
* 자신이 유도하거나 계산할 수 있는 것에 관한 아는 것

**객체지향 설계에서 가장 중요한 것은 책임이다.**

### 책임 할당
`정보 전문가 패턴` 책임을 수행하는 데 필요한 정보를 가장 잘 알고 있는 전문가에게 그 책임을 할당 하는것.
* 객체에게 책임을 할당하기 위해서 협력이라는 문맥을 정의해야 함
* 협력에 필요한 메시지를 찾고 적절한 객체를 선택하는 반복적인 과정을 통해 객체지향 설계가 이루어짐
* 이런 메시지가 메시지를 수신할 객체의 책임을 결정

### 책임 주도 설계
책임을 찾고 책임을 수행할 적절한 객체를 찾아 책임을 할당 하는 방식으로 협력을 설계 하는 것
* 시스템이 사용자에게 제공해야하는 기능인 시스템 책임을 파악한다.
* 시스템 책임을 더 작은 책임으로 분할한다.
* 분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당한다. 
* 객체가 책임을 수행하는 도중 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾는다.
* 해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 한다.

### 메시지가 객체를 결정한다.
메시지가 객체를 선택하게 해야 하는 이유
1. **객체가 최소한의 인터페이스를 가질 수 있게함.** 필요한 메시지가 식별될 때까지 객체의 퍼블릭 인터페이스에 어떤 것도 추가 하지 않기 때문에 필요한 크기의 퍼블릭 인터페이스를 가질 수 있음
2. **객체는 충분히 추상적인 인터페이스를 가질수 있게 됨**

### 행동이 상태를 결정한다.
* 객체가 협력에 적합한지를 결정하는 것은 상태가 아닌 행동임
* 초보자들은 상태에 초점을 맞추어 구현해 캡슐화를 지키지 못함
* 상태는 단지 객체가 행동을 정상적으로 수행하기 위해 필요한 지료일 뿐
* 상태는 행동을 결정하고 나서야 결정 할 수 있음
* 그 행동이 객체의 책임이 됨

## 역할

### 역할과 협력
`역할` 
* 객체가 어떤 특정한 협력 안에서 수행하는 책임의 집합
* 협력을 모델링할 때는 특정한 객체가 아니라 역할에게 책임을 할당한다고 생각하는게 좋음

### 유연하고 재사용 가능한 협력
* 역할을 통해 유연하고 재사용 가능한 협력을 얻을 수 있다.
* 역할은 다른 것으로 교체할 수 있는 책임의 집합이다.
* 동일한 책임을 수행하는 역할을 기반으로 두 개의 협력을 하나로 통합할 수 있다. 즉, 역할을 이용해 불필요한 중복 코드를 제거 할 수 있다.

### 객체 대 역할
> 레베카 워프스브록 言: 협력에 참여하는 후보가 여러 종류의 객체에 의해 수행될 필요가 있다면 그 후보는 역할이 되지만 단지 한 종류의 객체만이 협력에 참여할 필요가 있다면 후보는 객체가 된다.

**협력, 역할, 객체, 클래스의 관계**  
협력 -reference-> 역할 -select from -> 객체 -instance of-> 클래스

* 대부분의 경우에 어떤것이 역할이고 객체인디 또련하게 드러나지 않을 수 있음
* 설계 초반에는 적절한 책임과 협력의 큰 그림을 탐색하는 것이 중요한 목표여야 하고 객체를 명황하게 구분하는 것은 중요하지 않음 -> 단순 객체로 시작, 반복적으로 책임과 협력을 정제하면서 필요한 순간에 객체로부터 역할을 분리해내는것이 가장 좋음
* 다영한 객체들이 협력에 참여한다는 것이 확실하면 역할로 시작 but 정확한 결정을 내리기 어렵다면 구체적 객체로 시작

**협력을 구체적인 객체가 아니라 추상적인 역할의 관점에서 설계하면 협력이 유연하고 재사용 가능해짐. 역할의 가장 큰 장점은 설계 구성 요소를 추상화 할 수 있다는 것.**

### 역할과 추상화
추상화 이용 설계 장점
* 추상화 계층만을 이용하면 중요한 정책을 상위 수준에서 단순화
* 설계가 유연해짐  

역할은 객체의 추상화로 볼 수 있음 - 공통의 책임을 바탕으로 객체의 종류를 숨기기 때문

### 배우와 배역
연극 안에서 배역을 연기하는 배우라는 은유는 협력 안에서 역할을 수행하는 객체라는 관점이 가진 측면을 담아낸다.
* 연극 == 협력
* 극본 == 코드
* 배우는 연극이 상영될 때 배역이라는 특정한 역할 연기 == 객체는 협력이라는 실행 문맥 안에서 특정한 역할을 수행
* 객체는 다수의 역할 보유 가능
* 객체는 협력에 참여할 때 하나의 역할로 보여짐
* 객체가 다른 협력에 참여할 때는 다른 역할로 보여짐
* 협력의 관점에서 동일한 역할을 수행하는 객체들은 서로 대체 가능
* 역할은 특정한 객체 종류를 캡슐화 -> 동일한 역할을 수행하고 계약을 준수하는 대체 가능한 객체들은 다형적