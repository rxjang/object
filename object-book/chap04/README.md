# chap04 설계 품질과 트레이드오프

**객체 지향 설계의 핵심**
1. `역할` 대체 가능한 책임의 집합
2. `책임` 객체가 다른 객체와 협력하기 위해 수행하는 행동
3. `협력` 애플리케이션의 기능을 구현하기 위해 메시지를 주고받는 객체들 사이의 상호작용

## 시스템을 객체로 분할하는 두 가지 방법
1. 상태(데이터)를 분할의 중심축으로 삼는 방법
* 자신이 포함하고 있는 데이터를 조작하는 데 필요한 오퍼레이션을 정의
* 객체의 상태에 초점
* 객체: 독립된 데이터 덩어리
2. 책임을 분할의 중심축으로 삼는 방법
* 다른 객체가 요청할 수 있는 오퍼레이션을 위해 필요한 상태를 보관
* 객체의 행동에 초점
* 협력하는 공동체의 일원

> 훌륭한 객체 지향 설계는 데이터가 아니라 책임에 초점을 맞춰야 한다.  

* 객체의 상태는 구현에 속하는데, 구현은 불안정하기 때문에 변하기 쉽다. 
* 상태를 객체 분할의 중심축으로 삼으면 구현에 관한 세부사항이 객체의 인터페이스에 스며들어 캡슐화의 원칙이 무너진다.   

but,
* 객체의 책임은 인터페이스에 속한다.
* 안정적인 인터페이스 뒤로 책임을 수행하는데 필요한 상태를 캡슐화함으로써 구현 변경에 대한 파장이 외부로 퍼져나가는 것을 방지한다. 

## 설계 트레이드오프
**설계의 세 가지 품질 척도**
### 캡술화
외부에서 알 필요가 없는 부분을 감춤으로써 대상을 단순화하는 추상화의 한 종류.
* 불안정한 부분(구현)과 안정적인 부분(인터페이스)을 분리해서 변경의 영향을 통제
* 캡슐화 대상: 변경될 수 있는 어떤 것

### 응집도와 결합도
**응집도**
모듈에 포함된 내부 요소들이 연관돼 있는 정도
* 높은 응집도: 모듈 내의 요소들이 하나의 목적을 위해 긴밀하게 협력
* 낮은 응집도: 모듈 내의 요소들이 서로 다른 목적을 추구
* 객체 지향의 관점 -> 객체 또는 클래스에 얼마나 관련 높은 책임을 할당했는가

**결합도**
의존성의 정도. 다른 모듈에 대해 얼마나 많은 지식을 갖고 있는가 
* 높은 결합도: 어떤 모듈이 다른 모듈에 대해 너무 자세한 부분까지 알고 있을 경우
* 낮은 결합도: 어떤 모듈이 다른 모듈에 대해 꼭 필요한 지식만 알고 있을 경우
* 객체 지향의 관점 -> 객체 또는 클래스가 협력에 필요한 적절한 수준의 관계만을 유지하고 있는가

> 좋은 설계: 높은 응집도 & 낮은 결합도로 가진 모듈로 구성된 설계
> 이가 설계를 변경하기 쉽게 만듦

**캡슐화의 정도가 응집도와 결합도에 영향을 미친다.** 캡슐화를 지키면 모듈안의 응집도는 높아지고 모듈 사이의 결합도는 낮아진다.
응집도와 결합도를 고려하기 전, 캡슐화를 향상시키기 위해 노력하자.

## 데이터 중심 시스템의 문제점
설계 관점에서 데이터 중심의 설계는 캡슐화를 위반하고 객체의 내부 구현을 인터페이스로 일부 만든다. 이로 인해 응집도는 낮아지고 결합도가 높은 객체들이 양산될 가능성이 높아진다. 
> **단일 책임의 원칙**  
> 클래스는 단 한 가지의 변경 이유만 가져야 한다. 

## 자율적인 객체를 향해
### 캡슐화를 지켜라
캡슐화는 설걔의 제 1원리다. 객체는 자신이 어떤 데이터를 가지고 있는지를 내부에 캡슐화하고 외부에 공개해서는 안된다. 
객체는 스스로의 상태를 책임져야 하며 외부에서는 인터페이스에 정의된 메서드를 통해서만 상태에 접근할 수 있어야 한다.  

객체에게 의미 있는 메서드는 객체가 책임져야하는 무언가를 수행하는 메서드다. 속성의 가시성을 private으로 설정했다고 해도 접근자와 수정자를 통해 속성을 외부로 제공하고 있다면 캡슐화를 위반하는 것이다.
``` java
class Rectangle {
    private int left;
    private int top;
    private int right;
    private int bottom;
    
    public Rectangle(int left, int top, int right, int bottom) {
        this.left = left;
        this.top = top;
        this.right = right;
        this.bottom = bottom;
    }
    
    // getter & setter...
}
```
이 사각혀으이 너비와 높이를 증가시키는 코드가 필요하다면 다음과 같이 구현돼 있을 것이다.
``` java
class AnyClass{
    void anyMethod(Rectangle rectangle, int multiple) {
        rectangle.setRight(rectangle.getRight() * multiple);
        rectangle.setBottom(rectangle.getBottom() * multiple);
    }
}
```
이 코드에는 다음과 같은 문제점이 있다.
* 코드 중복이 발생할 확률이 높다. 다른 곳에서도 너비 or 높이를 증가시키는 코드가 필요하다면 이와 같은 유사한 코드가 존재할 것이다.
* 변경에 취약하다. top, left, bottom, right 의 인스턴스 변수를 외부에 노출시켜야 변경이 가능하다.  

해결 방법은 캡슐화를 강화시키는 것이다. 아래와 같은 캡슐화로 두가지 문제를 해결할 수 있다. 
``` java
class Rectangle {
    public void enlarge(int multiple) {
        right *= multiple;
        bottom *= multiple;
    }
}
```

### 스스로 자신의 데이터를 책임지는 객체
객체 스스로 자신의 상태를 처리할 수 있게 하기 위해 상태와 행동을 객체라는 단위로 묶는 것. 그러므로 다음 두 가지 질문을 통해 객체가 어떤 데이터를 포함해야 하는 것으로 설계 방향을 잡아야 한다.
* 이 객체가 어떤 데이터를 포함해야 하는가?
* 이 객체가 데이터에 대해 수행해야 하는 오퍼레이션은 무엇인가?

## 데이터 중심 설계의 문제점
데이터 중심의 설계가 변경에 취약한 두 가지 이유
* 데이터 중심의 설계는 본질적으로 너무 이른 시기에 데이터에 관해 결정하도록 강요한다.
* 데이터 중심의 설계에서는 협력이라는 문맥을 고려하지 않고 객체를 고립시킨 채 오퍼레이션을 결정한다.

### 데이터 중심 설계는 객체의 행동보다는 상태에 초점을 맞춘다.
대이터 중심 설계의 첫 번째 질문인 '이 객체가 어떤 데이터를 포함해야 하는가?' 때문에 너무 이른 시기에 내부 구현에 초점을 맞추게 된다. 
데이터를 먼저 결정하고 데이터를 처리하는 데 필요한 오퍼레이션을 나중에 결정하는 방식은 데이터에 관한 지식이 객체의 인터페이스에 드러나게 된다.
결과적으로 객체의 인어페이스는 구현을 캡슐화하는데 실패하고 코드는 변경에 취약해진다. 

### 데이터 중심 설계는 객체를 고립시킨채 오퍼레이션을 정의하도록 만든다.
데이터 중심설계에서 초점은 객체의 외부가 아니라 내부로 향한다. 객체의 구현이 이미 결정된 상태에서 다른 객체와의 협력 방법을 고민하기 때문에 이미 구현된 객체의 인터페이스를 억지로 끼워 맞출 수밖에 없다. 

